<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Software &amp; Algorithms – Lumos Imaging</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ef9176d5b3a494f395673aa65efdea21.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script>
  // Custom Scrollspy for fixed sidebar
  document.addEventListener('DOMContentLoaded', function () {
    const sidebar = document.querySelector('#quarto-margin-sidebar');
    if (!sidebar) return;

    const links = sidebar.querySelectorAll('.nav-link');
    const sections = [];

    links.forEach(link => {
      const href = link.getAttribute('href');
      if (href && href.startsWith('#')) {
        const id = href.substring(1);
        const section = document.getElementById(id);
        if (section) {
          sections.push({ link, section });
        }
      }
    });

    function updateActive() {
      const scrollPos = window.scrollY || document.documentElement.scrollTop;
      // Offset for navbar + some buffer
      const offset = 150;

      let current = null;

      // Find the current section
      for (let i = 0; i < sections.length; i++) {
        const { section } = sections[i];
        if (section.offsetTop <= scrollPos + offset) {
          current = sections[i];
        }
      }

      // Apply classes
      links.forEach(link => link.classList.remove('custom-active'));
      if (current) {
        current.link.classList.add('custom-active');
      } else if (sections.length > 0 && scrollPos < sections[0].section.offsetTop) {
        // Highlight first if near top? Optional. Quarto usually does first.
        sections[0].link.classList.add('custom-active');
      }
    }

    window.addEventListener('scroll', updateActive);
    updateActive(); // Init
  });
</script>
<script>
  // Set alt text for navbar logo images
  document.addEventListener('DOMContentLoaded', function () {
    const logoImages = document.querySelectorAll('.navbar-logo');
    logoImages.forEach(function (img) {
      if (!img.alt || img.alt === '') {
        img.alt = 'Lumos Imaging';
      }
    });

    // Ensure navbar has light theme
    const navbar = document.querySelector('.navbar');
    if (navbar) {
      navbar.setAttribute('data-bs-theme', 'light');
    }
  });
</script>
<script type="text/javascript">
  (function (c, l, a, r, i, t, y) {
    c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments) };
    t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
    y = l.getElementsByTagName(r)[0]; y.parentNode.insertBefore(t, y);
  })(window, document, "clarity", "script", "uklxny5jsc");
</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./assets/logos/Logo_LumosImaging_whitebackground.png" alt="" class="navbar-logo light-content">
    <img src="./assets/logos/Logo_LumosImaging_whitebackground.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Lumos Imaging</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./why_spectral_imaging.html"> 
<span class="menu-text">Why Spectral?</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./barriers_to_HSI_adoption.html"> 
<span class="menu-text">The Barriers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./lumos_solution.html"> 
<span class="menu-text">Lumos Hardware</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./lumos_algorithms.html" aria-current="page"> 
<span class="menu-text">Lumos Algorithms</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./validation_and_examples.html"> 
<span class="menu-text">Demos &amp; Validation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about_us.html"> 
<span class="menu-text">About Us</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-paradigm-shift-optical-compression" id="toc-the-paradigm-shift-optical-compression" class="nav-link active" data-scroll-target="#the-paradigm-shift-optical-compression">The Paradigm Shift: Optical Compression</a>
  <ul class="collapse">
  <li><a href="#video-demonstration-encoding-in-motion" id="toc-video-demonstration-encoding-in-motion" class="nav-link" data-scroll-target="#video-demonstration-encoding-in-motion">Video Demonstration: Encoding in Motion</a></li>
  </ul></li>
  <li><a href="#pathway-a-direct-inference-accessing-spectral-information-without-spectral-cubes" id="toc-pathway-a-direct-inference-accessing-spectral-information-without-spectral-cubes" class="nav-link" data-scroll-target="#pathway-a-direct-inference-accessing-spectral-information-without-spectral-cubes">Pathway A: Direct Inference (accessing spectral information without spectral cubes)</a></li>
  <li><a href="#pathway-b-traditional-spectral-cube-reconstruction" id="toc-pathway-b-traditional-spectral-cube-reconstruction" class="nav-link" data-scroll-target="#pathway-b-traditional-spectral-cube-reconstruction">Pathway B: Traditional Spectral Cube Reconstruction</a></li>
  <li><a href="#workflow-comparison" id="toc-workflow-comparison" class="nav-link" data-scroll-target="#workflow-comparison">Workflow Comparison</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Software &amp; Algorithms</h1>
<p class="subtitle lead">The Universal Spectral Container</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="the-paradigm-shift-optical-compression" class="level2">
<h2 class="anchored" data-anchor-id="the-paradigm-shift-optical-compression">The Paradigm Shift: Optical Compression</h2>
<p>In traditional spectral imaging, the hardware dictates the data format. You are forced to capture, store, and process massive 3D data cubes, even if you only need a fraction of that information.</p>
<p>Lumos flips this model.</p>
<p>Our hardware captures a <strong>Diffractogram</strong>—a raw, 2D grayscale image where spatial and spectral information is inextricably encoded by the laws of physics.</p>
<p><strong>Think of the Diffractogram as a “Universal Container.”</strong> It is an optically compressed file (typically &lt;1MB) that holds the full complexity of the scene. Because this container is so efficient, it opens up two distinct computational pathways: <strong>Direct Inference</strong> for modern data-driven machine learning situations, and <strong>Reconstruction</strong> for traditional spectral inspection of data and analysis.</p>
<section id="video-demonstration-encoding-in-motion" class="level3">
<h3 class="anchored" data-anchor-id="video-demonstration-encoding-in-motion">Video Demonstration: Encoding in Motion</h3>
<p>The following video illustrates the encoding process for a dynamic scene (a butterfly).</p>
<div class="wide-media">
<video src="assets/videos/butterfly.mp4" controls="" loop="" autoplay="" muted="" playsinline="">
</video>
</div>
<ul>
<li><strong>Hyperspectral (Left):</strong> The full 3D spectral cube is massive. In the video, you see the “unfolded” bands. We display only 25 spectral bands, but often systems acquire 100+ bands.</li>
<li><strong>RGB (Top Right):</strong> The standard color image we are used to. Low bandwidth, but low spectral information.</li>
<li><strong>Diffractogram (Bottom Right):</strong> This is the actual raw data captured by the Lumos sensor.
<ul>
<li><strong>Resolution:</strong> It is a single monochrome frame, identical in pixel count (HD)to a standard monochrome camera.</li>
<li><strong>Information Density:</strong> Despite being just one frame (smaller than RGB), it encodes the <em>entire</em> spectral complexity of the scene shown in the Hyperspectral view.</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="pathway-a-direct-inference-accessing-spectral-information-without-spectral-cubes" class="level2">
<h2 class="anchored" data-anchor-id="pathway-a-direct-inference-accessing-spectral-information-without-spectral-cubes">Pathway A: Direct Inference (accessing spectral information without spectral cubes)</h2>
<p><strong>“Why reconstruct a 50GB data cube just to answer a ‘Yes/No’ question?”</strong></p>
<p>For all applications, the goal is not to <em>see</em> the spectrum; the goal is to <em>act</em> on it. A sorting robot needs to know “Is this plastic PVC?” A satellite needs to know “Is this crop stressed?” A microscope needs to know “Is this cell cancerous?”</p>
<p>Lumos enables <strong>Direct Inference</strong>. We can use modern data-driven machine-learning frameworks and pipelines to use diffractograms directly, mapping the unique texture of the optical code to the desired answer, completely skipping the heavy reconstruction step. Unlike hyperspectral cubes which quickly become too big even for modern GPUs, diffractograms are even smaller than RGB images, making them ideal for edge devices, drones, satellites or on-demand cloud processing.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/images/path_B_direct_inference.png" class="img-fluid figure-img"></p>
<figcaption><strong>Direct Inference Pipeline.</strong> Deep Learning models ingest the raw diffractogram and directly output the desired variable (Class, Abundance, etc.), skipping the reconstruction step.</figcaption>
</figure>
</div>
<div class="lumos-solution">
<p><strong>Gamechanging advantages of Direct Inference</strong></p>
<ul>
<li><strong>Latency:</strong>: The small signal allows inference to take place on the edge.</li>
<li><strong>Bandwidth:</strong> Ideal for drones and satellites. Transmit the answer (bytes) or the compressed diffractogram (kilobytes) instead of the raw cube (gigabytes).</li>
<li><strong>Efficiency:</strong> Eliminates redundant computation. You don’t waste energy calculating spectral bands you don’t need. Storage is efficient and on-demand processing on the cloud becomes a possibility.</li>
</ul>
</div>
<hr>
</section>
<section id="pathway-b-traditional-spectral-cube-reconstruction" class="level2">
<h2 class="anchored" data-anchor-id="pathway-b-traditional-spectral-cube-reconstruction">Pathway B: Traditional Spectral Cube Reconstruction</h2>
<p>When human visualization or detailed scientific analysis is required, we use our <strong>Inverse Solver</strong> algorithms to decode the diffractogram back into a spectral Cube.</p>
<p>However, unlike traditional cameras where the bands are fixed by the hardware filters (e.g., “you only get these 10 bands”), Lumos offers <strong>Software-Defined Spectral Imaging</strong>. This means that we can dynamically select the bands we need after the signal has been acquired. This opens up a world of possibilities for on-demand spectral analysis.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/images/path_A_spectral_reconstruction.png" class="img-fluid figure-img"></p>
<figcaption><strong>Reconstruction Pipeline.</strong> The raw diffractogram is processed by the inverse solver to recover the spatio-spectral 3D cube.</figcaption>
</figure>
</div>
<div class="lumos-solution">
<p><strong>Gamechanging advantages of Direct Inference</strong></p>
<ul>
<li><strong>A Posteriori Selection:</strong> You can decide <em>after</em> taking the picture what spectral data you need.
<ul>
<li>Need 4 bands for agriculture? We generate them.</li>
<li>Need 25 bands for geology? We generate them from the <em>same</em> raw file.</li>
<li>Need to simulate a specific astronomical filter set (e.g., Johnson-Cousins)? We can do that mathematically.</li>
</ul></li>
<li><strong>Legacy Compatibility:</strong> The output can be saved as standard <code>.HDR</code> or <code>.ENVI</code> files, making Lumos data compatible with decades of existing spectral analysis software.</li>
</ul>
</div>
<hr>
</section>
<section id="workflow-comparison" class="level2">
<h2 class="anchored" data-anchor-id="workflow-comparison">Workflow Comparison</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Traditional HSI Workflow</th>
<th style="text-align: left;">Lumos Direct Inference</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Capture</strong></td>
<td style="text-align: left;">Scan scene (slow) or Snapshot (low res)</td>
<td style="text-align: left;"><strong>High-Resolution Snapshot</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Data Size</strong></td>
<td style="text-align: left;">Huge (GBs per minute)</td>
<td style="text-align: left;"><strong>Tiny (smaller than RGB)</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Processing</strong></td>
<td style="text-align: left;">Must process full 3D cube</td>
<td style="text-align: left;"><strong>Process only what matters</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Flexibility</strong></td>
<td style="text-align: left;">Hardware-fixed bands</td>
<td style="text-align: left;"><strong>User-defined bands, easily changed after capture</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Video</strong></td>
<td style="text-align: left;">Typically not possible</td>
<td style="text-align: left;"><strong>Same as CMOS sensor (e.g.&nbsp;30 FPS</strong></td>
</tr>
</tbody>
</table>
<p><a href="./validation_and_examples.html" class="btn btn-primary btn-lg mt-3"><strong>See our algorithms in action →</strong></a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>